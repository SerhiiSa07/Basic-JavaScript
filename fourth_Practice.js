// ------------////////////////------assignment----------/////////////------------

// Регулярные выражения используются в языках программирования для сопоставления частей строк. Вы создаете шаблоны, чтобы помочь вам сделать это сопоставление.

// Если вы хотите найти слово theв строке The dog chased the cat, вы можете использовать следующее регулярное выражение: /the/. Обратите внимание, что в регулярном выражении не требуются кавычки.

// В JavaScript есть несколько способов использования регулярных выражений. Один из способов проверить регулярное выражение — использовать .test() метод. Метод .test()принимает регулярное выражение, применяет его к строке (которая помещается в круглые скобки) и возвращает trueили false, если ваш шаблон что-то находит или нет.

// let testStr = "freeCodeCamp";
// let testRegex = /Code/;
// testRegex.test(testStr);
// Метод test здесь возвращает true.

// Примените регулярное выражение myRegex к строке myString, используя .test()метод.

//----------///////////------Answer-----------///////////--------------------

let myString = 'Hello, World!';
let myRegex = /Hello/;
let result = myRegex.test(myString); // Change this line

// ------------////////////////------assignment----------/////////////------------

// В последнем задании вы искали слово, Hello используя регулярное выражение /Hello/. Это регулярное выражение искало буквальное совпадение строки Hello. Вот еще один пример поиска буквального совпадения строки Kevin:

// let testStr = "Hello, my name is Kevin.";
// let testRegex = /Kevin/;
// testRegex.test(testStr);
// Этот testвызов вернется true.

// Любые другие формы Kevin не будут соответствовать. Например, регулярное выражение /Kevin/ не будет соответствовать kevin или KEVIN.

// let wrongRegex = /kevin/;
// wrongRegex.test(testStr);
// Этот test вызов вернется false.

// Будущая задача покажет, как сопоставить и эти другие формы.

// Завершите регулярное выражение waldoRegex, чтобы найти "Waldo" в строке waldoIsHiding буквальное совпадение.

//----------///////////------Answer-----------///////////--------------------

let waldoIsHiding = 'Somewhere Waldo is hiding in this text.';
let waldoRegex = /Waldo/; // Change this line
let result = waldoRegex.test(waldoIsHiding);

// ------------////////////////------assignment----------/////////////------------

// Используя регулярные выражения, такие как /coding/, вы можете искать шаблон coding в другой строке.

// Это мощный инструмент для поиска отдельных строк, но он ограничен только одним шаблоном. Вы можете искать несколько шаблонов, используя оператор alternation или : .OR|

// Этот оператор сопоставляет шаблоны либо до, либо после него. Например, если вы хотите сопоставить строки yes или no, вам нужно регулярное выражение /yes|no/.

// Вы также можете искать более двух шаблонов. Вы можете сделать это, добавив больше шаблонов с большим количеством OR операторов, разделяющих их, например /yes|no|maybe/.

// Заполните регулярное выражение petRegex, чтобы оно соответствовало домашним животным dog, cat, bird или fish.

//----------///////////------Answer-----------///////////--------------------

let petString = 'James has a pet cat.';
let petRegex = /dog|cat|bird|fish|change/; // Change this line
let result = petRegex.test(petString);

// ------------////////////////------assignment----------/////////////------------

// До сих пор вы рассматривали регулярные выражения для буквального сопоставления строк. Но иногда вы можете захотеть также сопоставить различия в регистре.

// Регистр (или иногда регистр букв) — это разница между прописными и строчными буквами. Примеры прописных букв: A, B, и C. Примерами нижнего регистра являются a, bи c.

// Вы можете сопоставить оба случая, используя так называемый флаг. Есть и другие флаги, но здесь вы сосредоточитесь на флаге, который игнорирует регистр — iфлаг. Вы можете использовать его, добавив в регулярное выражение. Пример использования этого флага /ignorecase/i. Это регулярное выражение может соответствовать строкам ignorecase, igNoreCaseи IgnoreCase.

// Напишите регулярное выражение fccRegex для соответствия freeCodeCamp независимо от регистра. Ваше регулярное выражение не должно соответствовать никаким аббревиатурам или вариациям с пробелами.

//----------///////////------Answer-----------///////////--------------------

let myString = 'freeCodeCamp';
let fccRegex = /freeCodeCamp/i; // Change this line
let result = fccRegex.test(myString);

// // ------------////////////////------assignment----------/////////////------------

// До сих пор вы только проверяли, существует ли шаблон в строке или нет. Вы также можете извлечь фактические совпадения, которые вы нашли с помощью .match()метода.

// Чтобы использовать .match()метод, примените метод к строке и передайте регулярное выражение в круглых скобках.

// Вот пример:

// "Hello, World!".match(/Hello/);
// let ourStr = "Regular expressions";
// let ourRegex = /expressions/;
// ourStr.match(ourRegex);
// Здесь вернется первый matchи вернется ["Hello"]второй ["expressions"].

// Обратите внимание, что .matchсинтаксис является «противоположным» .testметоду, который вы использовали до сих пор:

// 'string'.match(/regex/);
// /regex/.test('string');
// Примените .match()метод для извлечения строки coding.

//----------///////////------Answer-----------///////////--------------------

let extractStr = "Extract the word 'coding' from this string.";
let codingRegex = /coding/; // Change this line
let result = extractStr.match(/coding/); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// До сих пор вы могли извлекать или искать шаблон только один раз.

// let testStr = "Repeat, Repeat, Repeat";
// let ourRegex = /Repeat/;
// testStr.match(ourRegex);
// Вот matchбы вернуться ["Repeat"].

// Чтобы искать или извлекать шаблон более одного раза, вы можете использовать флаг глобального поиска: g.

// let repeatRegex = /Repeat/g;
// testStr.match(repeatRegex);
// И здесь matchвозвращает значение["Repeat", "Repeat", "Repeat"]

// Используя регулярное выражение starRegex, найдите и извлеките оба Twinkleслова из строки twinkleStar.

// Примечание.
// У вас может быть несколько флагов в вашем регулярном выражении, например/search/gi

//----------///////////------Answer-----------///////////--------------------

let twinkleStar = 'Twinkle, twinkle, little star';
let starRegex = /Twinkle/gi; // Change this line
let result = twinkleStar.match(starRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// Иногда вы не будете (или не должны) знать точные символы в своих шаблонах. Обдумывание всех слов, которые соответствуют, скажем, орфографической ошибке, заняло бы много времени. К счастью, вы можете сэкономить время, используя подстановочный знак.

// Подстановочный знак .будет соответствовать любому одному символу. Подстановочный знак также называется dotи period. Вы можете использовать подстановочный знак так же, как и любой другой символ в регулярном выражении. Например, если вы хотите сопоставить hug, huh, hutи hum, вы можете использовать регулярное выражение /hu./для сопоставления всех четырех слов.

// let humStr = "I'll hum a song";
// let hugStr = "Bear hug";
// let huRegex = /hu./;
// huRegex.test(humStr);
// huRegex.test(hugStr);
// Оба этих testвызова вернутся true.

// Завершите регулярное выражение unRegex, чтобы оно соответствовало строкам run, sun, fun, pun, nunи bun. Ваше регулярное выражение должно использовать подстановочный знак.

//----------///////////------Answer-----------///////////--------------------

let exampleStr = "Let's have fun with regular expressions!";
let unRegex = /.un/; // Change this line
let result = unRegex.test(exampleStr);

// // ------------////////////////------assignment----------/////////////------------

// Вы узнали, как сопоставлять литеральные шаблоны ( /literal/) и подстановочные знаки ( /./). Это крайности регулярных выражений, когда одно находит точные совпадения, а другое — все. Есть варианты, представляющие собой баланс между двумя крайностями.

// Вы можете искать буквальный шаблон с некоторой гибкостью с помощью классов символов . Классы символов позволяют вам определить группу символов, которые вы хотите сопоставить, поместив их в квадратные ( [и ]) скобки.

// Например, вы хотите сопоставить bag, bigи , bugно не bog. Вы можете создать регулярное выражение /b[aiu]g/для этого. Это [aiu]класс символов, который будет соответствовать только символам a, iили u.

// let bigStr = "big";
// let bagStr = "bag";
// let bugStr = "bug";
// let bogStr = "bog";
// let bgRegex = /b[aiu]g/;
// bigStr.match(bgRegex);
// bagStr.match(bgRegex);
// bugStr.match(bgRegex);
// bogStr.match(bgRegex);
// По порядку четыре matchвызова вернут значения ["big"], ["bag"], ["bug"]и null.

// Используйте класс символов с гласными ( a, e, i, o, u) в регулярном выражении vowelRegex, чтобы найти все гласные в строке quoteSample.

// Примечание. Убедитесь, что гласные в верхнем и нижнем регистре совпадают.

//----------///////////------Answer-----------///////////--------------------

let quoteSample =
  'Beware of bugs in the above code; I have only proved it correct, not tried it.';
let vowelRegex = /[aeiou]/gi; // Change this line
let result = quoteSample.match(vowelRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// Вы видели, как можно использовать наборы символов, чтобы указать группу символов для сопоставления, но это требует много времени, когда вам нужно сопоставить большой диапазон символов (например, каждую букву алфавита). К счастью, есть встроенная функция, которая делает это коротким и простым.

// Внутри набора символов вы можете определить диапазон символов для соответствия с помощью символа дефиса: -.

// Например, чтобы сопоставить строчные буквы , вы должны aиспользовать .e[a-e]

// let catStr = "cat";
// let batStr = "bat";
// let matStr = "mat";
// let bgRegex = /[a-e]at/;
// catStr.match(bgRegex);
// batStr.match(bgRegex);
// matStr.match(bgRegex);
// По порядку три matchвызова вернут значения ["cat"], ["bat"]и null.

// Сопоставьте все буквы в строке quoteSample.

// Примечание . Убедитесь, что совпадают как прописные, так и строчные буквы.

//----------///////////------Answer-----------///////////--------------------

let quoteSample = 'The quick brown fox jumps over the lazy dog.';
let alphabetRegex = /[a-z]/gi; // Change this line
let result = quoteSample.match(alphabetRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// Использование дефиса (-) для соответствия диапазону символов не ограничивается буквами. Он также работает, чтобы соответствовать диапазону чисел.

// Например, /[0-5]/соответствует любому числу между 0 и 5, включая 0 и 5.

// Кроме того, можно комбинировать диапазон букв и цифр в одном наборе символов.

// let jennyStr = "Jenny8675309";
// let myRegex = /[a-z0-9]/ig;
// jennyStr.match(myRegex);
// Создайте одно регулярное выражение, которое соответствует диапазону букв между hи sи диапазону чисел между 2и 6. Не забудьте включить соответствующие флаги в регулярное выражение.

//----------///////////------Answer-----------///////////--------------------

let quoteSample = 'Blueberry 3.141592653s are delicious.';
let myRegex = /[h-s2-6]/gi; // Change this line
let result = quoteSample.match(myRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// До сих пор вы создали набор символов, которые вы хотите сопоставить, но вы также можете создать набор символов, которые вы не хотите сопоставлять. Эти типы наборов символов называются наборами символов с отрицанием .

// Чтобы создать набор символов с отрицанием, вы помещаете символ вставки (^) после открывающей скобки и перед символами, которые не должны совпадать.

// Например, /[^aeiou]/giсоответствует всем символам, не являющимся гласными. Обратите внимание, что такие символы, как ., !, [, @, /и пробел совпадают — набор символов с отрицанием гласных исключает только символы гласных.

// Создайте одно регулярное выражение, которое соответствует всем символам, не являющимся числом или гласной. Не забудьте включить соответствующие флаги в регулярное выражение.

//----------///////////------Answer-----------///////////--------------------

let quoteSample = '3 blind mice.';
let myRegex = /[^aeiou^0-99]/gi; // Change this line
let result = quoteSample.match(myRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// Иногда вам нужно сопоставить символ (или группу символов), который появляется один или несколько раз подряд. Это означает, что это происходит хотя бы один раз и может повторяться.

// Вы можете использовать +символ, чтобы проверить, так ли это. Помните, что символ или шаблон должны присутствовать последовательно. То есть персонаж должен повторяться один за другим.

// Например, /a+/gнайдет одно совпадение abcи вернет ["a"]. Из-за +, он также найдет одно совпадение aabcи вернет ["aa"].

// Если бы он вместо этого проверял строку abab, он нашел бы два совпадения и вернул бы результат, ["a", "a"]потому что aсимволы не стоят в строке — b между ними есть знак. Наконец, поскольку aв строке bcdнет, совпадение не будет найдено.

// Вы хотите найти совпадения, когда буква sвстречается один или несколько раз в Mississippi. Напишите регулярное выражение, использующее + знак.

//----------///////////------Answer-----------///////////--------------------

let difficultSpelling = 'Mississippi';
let myRegex = /s+/g; // Change this line
let result = difficultSpelling.match(myRegex);

// // ------------////////////////------assignment----------/////////////------------

// В последней задаче +знак «плюс» использовался для поиска символов, встречающихся один или несколько раз. Существует также параметр, который соответствует символам, встречающимся ноль или более раз.

// Символ для этого — звездочка или звездочка: *.

// let soccerWord = "gooooooooal!";
// let gPhrase = "gut feeling";
// let oPhrase = "over the moon";
// let goRegex = /go*/;
// soccerWord.match(goRegex);
// gPhrase.match(goRegex);
// oPhrase.match(goRegex);
// По порядку три matchвызова вернут значения ["goooooooo"], ["g"]и null.

// Для этой задачи chewieQuoteбыла инициализирована строка Aaaaaaaaaaaaaaaarrrgh!за кулисами. Создайте регулярное выражение chewieRegex, которое использует *символ для сопоставления Aсимвола верхнего регистра, за которым непосредственно следует ноль или более aсимволов нижнего регистра в chewieQuote. Вашему регулярному выражению не нужны флаги или классы символов, и оно не должно совпадать ни с какими другими кавычками.

//----------///////////------Answer-----------///////////--------------------

// Only change code below this line
let chewieRegex = /Aa*/; // Change this line
// Only change code above this line

let result = chewieQuote.match(chewieRegex);

// // ------------////////////////------assignment----------/////////////------------

// В регулярных выражениях жадное совпадение находит максимально длинную часть строки, которая соответствует шаблону регулярного выражения, и возвращает ее как совпадение. Альтернатива называется ленивым сопоставлением, которое находит наименьшую возможную часть строки, удовлетворяющую шаблону регулярного выражения.

// Вы можете применить регулярное выражение /t[a-z]*i/к строке "titanic". Это регулярное выражение в основном представляет собой шаблон, который начинается с t, заканчивается на i и имеет несколько букв между ними.

// Регулярные выражения по умолчанию являются жадными, поэтому совпадение возвращает ["titani"]. Он находит самую большую подстроку, соответствующую шаблону.

// Однако вы можете использовать ? символ, чтобы изменить его на ленивое сопоставление. "titanic"сопоставляется с скорректированным регулярным выражением /t[a-z]*?i/return ["ti"].

// Примечание. Следует избегать синтаксического анализа HTML с помощью регулярных выражений, но сопоставление шаблона строки HTML с регулярными выражениями вполне допустимо.

// Исправьте регулярное выражение /<.*>/, чтобы оно возвращало тег HTML, <h1>а не текст "<h1>Winter is coming</h1>". Помните, что подстановочный знак .в регулярном выражении соответствует любому символу.

//----------///////////------Answer-----------///////////--------------------

let text = '<h1>Winter is coming</h1>';
let myRegex = /<.*?>/; // Change this line
let result = text.match(myRegex);

// // ------------////////////////------assignment----------/////////////------------

// Время сделать паузу и проверить свои новые навыки написания регулярных выражений. Группа преступников сбежала из тюрьмы и сбежала, но вы не знаете, сколько. Однако вы знаете, что они держатся вместе, когда находятся рядом с другими людьми. Вы несете ответственность за обнаружение всех преступников сразу.

// Вот пример, чтобы рассмотреть, как это сделать:

// Регулярное выражение /z+/соответствует букве z, когда она появляется один или несколько раз подряд. Он найдет совпадения во всех следующих строках:

// "z"
// "zzzzzz"
// "ABCzzzz"
// "zzzzABC"
// "abczzzzzzzzzzzzzzzzzzzzzabc"
// Но он не находит совпадений в следующих строках, так как в них нет буквенных zсимволов:

// ""
// "ABC"
// "abcabc"
// Напишите жадное регулярное выражение, которое находит одного или нескольких преступников в группе других людей. Преступника изображают с большой буквы C.

//----------///////////------Answer-----------///////////--------------------

let reCriminals = /C+/; // Change this line

// // ------------////////////////------assignment----------/////////////------------

// Предыдущие испытания показали, что регулярные выражения можно использовать для поиска ряда совпадений. Они также используются для поиска шаблонов в определенных позициях в строках.

// В более ранней задаче вы использовали символ вставки ( ^) внутри набора символов для создания набора символов с отрицанием в форме [^thingsThatWillNotBeMatched]. Вне набора символов знак вставки используется для поиска шаблонов в начале строк.

// let firstString = "Ricky is first and can be found.";
// let firstRegex = /^Ricky/;
// firstRegex.test(firstString);
// let notFirst = "You can't find Ricky now.";
// firstRegex.test(notFirst);
// Первый testвызов вернется true, а второй вернется false.

// Используйте символ вставки в регулярном выражении для поиска Calтолько в начале строки rickyAndCal.

//----------///////////------Answer-----------///////////--------------------

let rickyAndCal = 'Cal and Ricky both like racing.';
let calRegex = /^Cal/; // Change this line
let result = calRegex.test(rickyAndCal);

// // ------------////////////////------assignment----------/////////////------------

// В последнем задании вы научились использовать символ вставки для поиска шаблонов в начале строк. Существует также способ поиска шаблонов в конце строк.

// Вы можете искать конец строки, используя символ доллара $в конце регулярного выражения.

// let theEnding = "This is a never ending story";
// let storyRegex = /story$/;
// storyRegex.test(theEnding);
// let noEnding = "Sometimes a story will have to end";
// storyRegex.test(noEnding);
// Первый testвызов вернется true, а второй вернется false.

// Используйте символ привязки ( $) для сопоставления строки cabooseв конце строки caboose.

//----------///////////------Answer-----------///////////--------------------

let caboose = 'The last car on a train is the caboose';
let lastRegex = /caboose$/; // Change this line
let result = lastRegex.test(caboose);

// // ------------////////////////------assignment----------/////////////------------

// Используя классы символов, вы могли искать все буквы алфавита с помощью [a-z]. Этот тип класса символов достаточно распространен, поэтому для него есть ярлык, хотя он также включает в себя несколько дополнительных символов.

// Ближайший класс символов в JavaScript, соответствующий алфавиту, — это \w. Этот ярлык равен [A-Za-z0-9_]. Этот класс символов соответствует прописным и строчным буквам, а также цифрам. Обратите внимание, что этот класс символов также включает символ подчеркивания ( _).

// let longHand = /[A-Za-z0-9_]+/;
// let shortHand = /\w+/;
// let numbers = "42";
// let varNames = "important_var";
// longHand.test(numbers);
// shortHand.test(numbers);
// longHand.test(varNames);
// shortHand.test(varNames);
// Все четыре из этих testвызовов вернутся true.

// Эти классы сокращенных символов также известны как классы сокращенных символов .

// Используйте класс сокращенных символов \wдля подсчета количества буквенно-цифровых символов в различных кавычках и строках.

//----------///////////------Answer-----------///////////--------------------

let quoteSample = 'The five boxing wizards jump quickly.';
let alphabetRegexV2 = /\w/g; // Change this line
let result = quoteSample.match(alphabetRegexV2).length;
