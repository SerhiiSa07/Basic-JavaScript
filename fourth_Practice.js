// ------------////////////////------assignment----------/////////////------------

// Регулярные выражения используются в языках программирования для сопоставления частей строк. Вы создаете шаблоны, чтобы помочь вам сделать это сопоставление.

// Если вы хотите найти слово theв строке The dog chased the cat, вы можете использовать следующее регулярное выражение: /the/. Обратите внимание, что в регулярном выражении не требуются кавычки.

// В JavaScript есть несколько способов использования регулярных выражений. Один из способов проверить регулярное выражение — использовать .test() метод. Метод .test()принимает регулярное выражение, применяет его к строке (которая помещается в круглые скобки) и возвращает trueили false, если ваш шаблон что-то находит или нет.

// let testStr = "freeCodeCamp";
// let testRegex = /Code/;
// testRegex.test(testStr);
// Метод test здесь возвращает true.

// Примените регулярное выражение myRegex к строке myString, используя .test()метод.

//----------///////////------Answer-----------///////////--------------------

let myString = 'Hello, World!';
let myRegex = /Hello/;
let result = myRegex.test(myString); // Change this line

// ------------////////////////------assignment----------/////////////------------

// В последнем задании вы искали слово, Hello используя регулярное выражение /Hello/. Это регулярное выражение искало буквальное совпадение строки Hello. Вот еще один пример поиска буквального совпадения строки Kevin:

// let testStr = "Hello, my name is Kevin.";
// let testRegex = /Kevin/;
// testRegex.test(testStr);
// Этот testвызов вернется true.

// Любые другие формы Kevin не будут соответствовать. Например, регулярное выражение /Kevin/ не будет соответствовать kevin или KEVIN.

// let wrongRegex = /kevin/;
// wrongRegex.test(testStr);
// Этот test вызов вернется false.

// Будущая задача покажет, как сопоставить и эти другие формы.

// Завершите регулярное выражение waldoRegex, чтобы найти "Waldo" в строке waldoIsHiding буквальное совпадение.

//----------///////////------Answer-----------///////////--------------------

let waldoIsHiding = 'Somewhere Waldo is hiding in this text.';
let waldoRegex = /Waldo/; // Change this line
let result = waldoRegex.test(waldoIsHiding);

// ------------////////////////------assignment----------/////////////------------

// Используя регулярные выражения, такие как /coding/, вы можете искать шаблон coding в другой строке.

// Это мощный инструмент для поиска отдельных строк, но он ограничен только одним шаблоном. Вы можете искать несколько шаблонов, используя оператор alternation или : .OR|

// Этот оператор сопоставляет шаблоны либо до, либо после него. Например, если вы хотите сопоставить строки yes или no, вам нужно регулярное выражение /yes|no/.

// Вы также можете искать более двух шаблонов. Вы можете сделать это, добавив больше шаблонов с большим количеством OR операторов, разделяющих их, например /yes|no|maybe/.

// Заполните регулярное выражение petRegex, чтобы оно соответствовало домашним животным dog, cat, bird или fish.

//----------///////////------Answer-----------///////////--------------------

let petString = 'James has a pet cat.';
let petRegex = /dog|cat|bird|fish|change/; // Change this line
let result = petRegex.test(petString);

// ------------////////////////------assignment----------/////////////------------

// До сих пор вы рассматривали регулярные выражения для буквального сопоставления строк. Но иногда вы можете захотеть также сопоставить различия в регистре.

// Регистр (или иногда регистр букв) — это разница между прописными и строчными буквами. Примеры прописных букв: A, B, и C. Примерами нижнего регистра являются a, bи c.

// Вы можете сопоставить оба случая, используя так называемый флаг. Есть и другие флаги, но здесь вы сосредоточитесь на флаге, который игнорирует регистр — iфлаг. Вы можете использовать его, добавив в регулярное выражение. Пример использования этого флага /ignorecase/i. Это регулярное выражение может соответствовать строкам ignorecase, igNoreCaseи IgnoreCase.

// Напишите регулярное выражение fccRegex для соответствия freeCodeCamp независимо от регистра. Ваше регулярное выражение не должно соответствовать никаким аббревиатурам или вариациям с пробелами.

//----------///////////------Answer-----------///////////--------------------

let myString = 'freeCodeCamp';
let fccRegex = /freeCodeCamp/i; // Change this line
let result = fccRegex.test(myString);

// // ------------////////////////------assignment----------/////////////------------

// До сих пор вы только проверяли, существует ли шаблон в строке или нет. Вы также можете извлечь фактические совпадения, которые вы нашли с помощью .match()метода.

// Чтобы использовать .match()метод, примените метод к строке и передайте регулярное выражение в круглых скобках.

// Вот пример:

// "Hello, World!".match(/Hello/);
// let ourStr = "Regular expressions";
// let ourRegex = /expressions/;
// ourStr.match(ourRegex);
// Здесь вернется первый matchи вернется ["Hello"]второй ["expressions"].

// Обратите внимание, что .matchсинтаксис является «противоположным» .testметоду, который вы использовали до сих пор:

// 'string'.match(/regex/);
// /regex/.test('string');
// Примените .match()метод для извлечения строки coding.

//----------///////////------Answer-----------///////////--------------------

let extractStr = "Extract the word 'coding' from this string.";
let codingRegex = /coding/; // Change this line
let result = extractStr.match(/coding/); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// До сих пор вы могли извлекать или искать шаблон только один раз.

// let testStr = "Repeat, Repeat, Repeat";
// let ourRegex = /Repeat/;
// testStr.match(ourRegex);
// Вот matchбы вернуться ["Repeat"].

// Чтобы искать или извлекать шаблон более одного раза, вы можете использовать флаг глобального поиска: g.

// let repeatRegex = /Repeat/g;
// testStr.match(repeatRegex);
// И здесь matchвозвращает значение["Repeat", "Repeat", "Repeat"]

// Используя регулярное выражение starRegex, найдите и извлеките оба Twinkleслова из строки twinkleStar.

// Примечание.
// У вас может быть несколько флагов в вашем регулярном выражении, например/search/gi

//----------///////////------Answer-----------///////////--------------------

let twinkleStar = 'Twinkle, twinkle, little star';
let starRegex = /Twinkle/gi; // Change this line
let result = twinkleStar.match(starRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// Иногда вы не будете (или не должны) знать точные символы в своих шаблонах. Обдумывание всех слов, которые соответствуют, скажем, орфографической ошибке, заняло бы много времени. К счастью, вы можете сэкономить время, используя подстановочный знак.

// Подстановочный знак .будет соответствовать любому одному символу. Подстановочный знак также называется dotи period. Вы можете использовать подстановочный знак так же, как и любой другой символ в регулярном выражении. Например, если вы хотите сопоставить hug, huh, hutи hum, вы можете использовать регулярное выражение /hu./для сопоставления всех четырех слов.

// let humStr = "I'll hum a song";
// let hugStr = "Bear hug";
// let huRegex = /hu./;
// huRegex.test(humStr);
// huRegex.test(hugStr);
// Оба этих testвызова вернутся true.

// Завершите регулярное выражение unRegex, чтобы оно соответствовало строкам run, sun, fun, pun, nunи bun. Ваше регулярное выражение должно использовать подстановочный знак.

//----------///////////------Answer-----------///////////--------------------

let exampleStr = "Let's have fun with regular expressions!";
let unRegex = /.un/; // Change this line
let result = unRegex.test(exampleStr);

// // ------------////////////////------assignment----------/////////////------------

// Вы узнали, как сопоставлять литеральные шаблоны ( /literal/) и подстановочные знаки ( /./). Это крайности регулярных выражений, когда одно находит точные совпадения, а другое — все. Есть варианты, представляющие собой баланс между двумя крайностями.

// Вы можете искать буквальный шаблон с некоторой гибкостью с помощью классов символов . Классы символов позволяют вам определить группу символов, которые вы хотите сопоставить, поместив их в квадратные ( [и ]) скобки.

// Например, вы хотите сопоставить bag, bigи , bugно не bog. Вы можете создать регулярное выражение /b[aiu]g/для этого. Это [aiu]класс символов, который будет соответствовать только символам a, iили u.

// let bigStr = "big";
// let bagStr = "bag";
// let bugStr = "bug";
// let bogStr = "bog";
// let bgRegex = /b[aiu]g/;
// bigStr.match(bgRegex);
// bagStr.match(bgRegex);
// bugStr.match(bgRegex);
// bogStr.match(bgRegex);
// По порядку четыре matchвызова вернут значения ["big"], ["bag"], ["bug"]и null.

// Используйте класс символов с гласными ( a, e, i, o, u) в регулярном выражении vowelRegex, чтобы найти все гласные в строке quoteSample.

// Примечание. Убедитесь, что гласные в верхнем и нижнем регистре совпадают.

//----------///////////------Answer-----------///////////--------------------

let quoteSample =
  'Beware of bugs in the above code; I have only proved it correct, not tried it.';
let vowelRegex = /[aeiou]/gi; // Change this line
let result = quoteSample.match(vowelRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// Вы видели, как можно использовать наборы символов, чтобы указать группу символов для сопоставления, но это требует много времени, когда вам нужно сопоставить большой диапазон символов (например, каждую букву алфавита). К счастью, есть встроенная функция, которая делает это коротким и простым.

// Внутри набора символов вы можете определить диапазон символов для соответствия с помощью символа дефиса: -.

// Например, чтобы сопоставить строчные буквы , вы должны aиспользовать .e[a-e]

// let catStr = "cat";
// let batStr = "bat";
// let matStr = "mat";
// let bgRegex = /[a-e]at/;
// catStr.match(bgRegex);
// batStr.match(bgRegex);
// matStr.match(bgRegex);
// По порядку три matchвызова вернут значения ["cat"], ["bat"]и null.

// Сопоставьте все буквы в строке quoteSample.

// Примечание . Убедитесь, что совпадают как прописные, так и строчные буквы.

//----------///////////------Answer-----------///////////--------------------

let quoteSample = 'The quick brown fox jumps over the lazy dog.';
let alphabetRegex = /[a-z]/gi; // Change this line
let result = quoteSample.match(alphabetRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// Использование дефиса (-) для соответствия диапазону символов не ограничивается буквами. Он также работает, чтобы соответствовать диапазону чисел.

// Например, /[0-5]/соответствует любому числу между 0 и 5, включая 0 и 5.

// Кроме того, можно комбинировать диапазон букв и цифр в одном наборе символов.

// let jennyStr = "Jenny8675309";
// let myRegex = /[a-z0-9]/ig;
// jennyStr.match(myRegex);
// Создайте одно регулярное выражение, которое соответствует диапазону букв между hи sи диапазону чисел между 2и 6. Не забудьте включить соответствующие флаги в регулярное выражение.

//----------///////////------Answer-----------///////////--------------------

let quoteSample = 'Blueberry 3.141592653s are delicious.';
let myRegex = /[h-s2-6]/gi; // Change this line
let result = quoteSample.match(myRegex); // Change this line

// // ------------////////////////------assignment----------/////////////------------

// До сих пор вы создали набор символов, которые вы хотите сопоставить, но вы также можете создать набор символов, которые вы не хотите сопоставлять. Эти типы наборов символов называются наборами символов с отрицанием .

// Чтобы создать набор символов с отрицанием, вы помещаете символ вставки (^) после открывающей скобки и перед символами, которые не должны совпадать.

// Например, /[^aeiou]/giсоответствует всем символам, не являющимся гласными. Обратите внимание, что такие символы, как ., !, [, @, /и пробел совпадают — набор символов с отрицанием гласных исключает только символы гласных.

// Создайте одно регулярное выражение, которое соответствует всем символам, не являющимся числом или гласной. Не забудьте включить соответствующие флаги в регулярное выражение.

//----------///////////------Answer-----------///////////--------------------

let quoteSample = '3 blind mice.';
let myRegex = /[^aeiou^0-99]/gi; // Change this line
let result = quoteSample.match(myRegex); // Change this line
