// --------------------------------assignments-------------

// 1) Заполните новый массив (result) числами из старого (arr). Количество элементов в массиве можно получить как arr.length, а к элементам обращаемся все так же: arr[0], arr[1] и тд.
// Должен получиться точно такой же массив

// 2) Измените данный массив так, чтобы все числа были увеличены в 2 раза, а если попадается строка строка - то к ней было добавлено " - done".
// Для определения типа данных используйте typeof();
// Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ]

// 3) Разверните массив data наоборот при помощи цикла и запишите данные в массив result.
// Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]

// ------------------------------- Answer  - -- ----------

function firstTask() {
  const arr = [3, 5, 8, 16, 20, 23, 50];
  const result = [];

  for (let i = 0; i < arr.length; i++) {
    result[i] = arr[i];
  }

  console.log(result);
  return result;
}

firstTask();

function secondTask() {
  const data = [5, 10, 'Shopping', 20, 'Homework'];

  for (let i = 0; i < data.length; i++) {
    if (typeof data[i] === 'number') {
      data[i] = data[i] * 2;
    } else if (typeof data[i] === 'string') {
      data[i] = `${data[i]} - done`;
    }
  }

  console.log(data);
  return data;
}

secondTask();

function thirdTask() {
  const data = [5, 10, 'Shopping', 20, 'Homework'];
  const result = [];

  for (let i = 1; i <= data.length; i++) {
    result[i - 1] = data[data.length - i];
  }

  console.log(result);
  return result;
}

thirdTask();

// --------------------------------assignments-------------

// 4)
//      *
//     ***
//    *****
//   *******
//  *********
// ***********

// ------------------------------- Answer  - -- ----------

const lines = 5;
let result = '';

for (let i = 0; i <= lines; i++) {
  for (let j = 0; j < lines - i; j++) {
    result += ' ';
  }
  for (let j = 0; j < 2 * i + 1; j++) {
    result += '*';
  }
  result += '\n';
}

console.log(result);

// --------------------------------assignments-------------

//5) Это упражнение предназначено для того, чтобы проиллюстрировать разницу между тем, как ключевые слова varи letназначают область действия объявленной переменной. При программировании функции, подобной той, что используется в этом упражнении, часто лучше использовать разные имена переменных, чтобы избежать путаницы.

// ------------------------------- Answer  - -- ----------

function checkScope() {
  let i = 'function scope';
  if (true) {
    let i = 'block scope';
    console.log('Block scope i is: ', i);
  }
  console.log('Function scope i is: ', i);
  return i;
}

// --------------------------------assignments-------------

// Если вы не знакомы с const, проверьте этот вызов о constключевом слове .

// Объявление constимеет множество вариантов использования в современном JavaScript.

// Некоторые разработчики предпочитают присваивать всем своим переменным constзначение по умолчанию, если только они не знают, что им потребуется переназначить значение. Только в этом случае они используют let.

// Однако важно понимать, что объекты (включая массивы и функции), назначенные переменной с помощью const, по-прежнему могут изменяться. Использование constобъявления только предотвращает переназначение идентификатора переменной.

// const s = [5, 6, 7];
// s = [1, 2, 3];
// s[2] = 45;
// console.log(s);
// s = [1, 2, 3]приведет к ошибке. После комментирования этой строки console.logбудет отображаться значение [5, 6, 45].

// Как видите, вы можете изменить сам объект [5, 6, 7], и переменная sвсе равно будет указывать на измененный массив [5, 6, 45]. Как и все массивы, элементы массива sявляются изменяемыми, но поскольку constиспользуется, вы не можете использовать идентификатор переменной sдля указания на другой массив с помощью оператора присваивания.

//6) Массив объявляется как const s = [5, 7, 2]. Измените массив на [2, 5, 7]использование различных назначений элементов.

// ------------------------------- Answer  - -- ----------

const s = [5, 7, 2];
function editInPlace() {
  // Only change code below this line
  (s[0] = 2), (s[1] = 5), (s[2] = 7);
  // Using s = [2, 5, 7] would be invalid

  // Only change code above this line
}
editInPlace();

// --------------------------------assignments-------------

// Как видно из предыдущей задачи, const объявление само по себе на самом деле не защищает ваши данные от изменений. Чтобы гарантировать, что ваши данные не изменятся, JavaScript предоставляет функцию Object.freezeпредотвращения изменения данных.

// Любая попытка изменить объект будет отклонена с выдачей ошибки, если скрипт работает в строгом режиме.

// let obj = {
//   name:"FreeCodeCamp",
//   review:"Awesome"
// };
// Object.freeze(obj);
// obj.review = "bad";
// obj.newProp = "Test";
// console.log(obj);
// Присваивания obj.reviewи obj.newPropприведут к ошибкам, потому что наш редактор по умолчанию работает в строгом режиме, и в консоли будет отображаться значение { name: "FreeCodeCamp", review: "Awesome" }.

//7) В этом задании вы будете использовать Object.freezeдля предотвращения изменения математических констант. Вам нужно заморозить MATH_CONSTANTSобъект, чтобы никто не мог изменить значение PI, добавить или удалить свойства.

// ------------------------------- Answer  - -- ----------

function freezeObj() {
  const MATH_CONSTANTS = {
    PI: 3.14,
  };
  // Only change code below this line

  // Only change code above this line
  try {
    MATH_CONSTANTS.PI = 99;
  } catch (ex) {
    console.log(ex);
  }
  return MATH_CONSTANTS.PI;
}
const PI = 3.14;

// --------------------------------assignments-------------

// В JavaScript нам часто не нужно называть наши функции, особенно при передаче функции в качестве аргумента другой функции. Вместо этого мы создаем встроенные функции. Нам не нужно называть эти функции, потому что мы больше нигде их не используем.

// Для этого мы часто используем следующий синтаксис:

// const myFunc = function() {
//   const myVar = "value";
//   return myVar;
// }
// ES6 предоставляет нам синтаксический сахар, позволяющий не писать анонимные функции таким образом. Вместо этого вы можете использовать синтаксис стрелочной функции :

// const myFunc = () => {
//   const myVar = "value";
//   return myVar;
// }
// Когда тело функции отсутствует, а есть только возвращаемое значение, синтаксис стрелочной функции позволяет опустить ключевое слово return, а также скобки, окружающие код. Это помогает упростить небольшие функции до однострочных инструкций:

// const myFunc = () => "value";
// Этот код по-прежнему будет возвращать строку valueпо умолчанию.

//8) Перепишите функцию, назначенную переменной magic, которая возвращает a, new Date()чтобы использовать синтаксис стрелочной функции. Кроме того, убедитесь, что ничего не определено с использованием ключевого слова var.

// ------------------------------- Answer -------------------------

const magic = () => new Date();

// --------------------------------assignments-------------

// Как и в случае с обычной функцией, вы можете передавать аргументы в функцию со стрелкой.

// const doubler = (item) => item * 2;
// doubler(4);
// doubler(4)вернет значение 8.

// Если стрелочная функция имеет один параметр, круглые скобки, заключающие этот параметр, могут быть опущены.

// const doubler = item => item * 2;
// В стрелочную функцию можно передать более одного аргумента.

// const multiplier = (item, multi) => item * multi;
// multiplier(4, 2);
// multiplier(4, 2)вернет значение 8.

// 9) Перепишите myConcatфункцию, которая добавляет содержимое arr2к arr1, чтобы она использовала синтаксис стрелочной функции.

// ------------------------------- Answer -------------------------

const myConcat = (arr1, arr2) => arr1.concat(arr2);

console.log(myConcat([1, 2], [3, 4, 5]));

// --------------------------------assignments-------------

// Чтобы помочь нам создавать более гибкие функции, ES6 вводит параметры по умолчанию для функций.

// Проверьте этот код:

// const greeting = (name = "Anonymous") => "Hello " + name;

// console.log(greeting("John"));
// console.log(greeting());
// Консоль отобразит строки Hello Johnи Hello Anonymous.

// Параметр по умолчанию срабатывает, когда аргумент не указан (он не определен). Как вы можете видеть в приведенном выше примере, параметр nameполучит значение по умолчанию, Anonymousесли вы не укажете значение для параметра. Вы можете добавить значения по умолчанию для любого количества параметров.

// 10) Измените функцию increment, добавив параметры по умолчанию, чтобы она добавляла 1, number если value не указано.

// ------------------------------- Answer -------------------------

// Only change code below this line
const increment = (number, value = 1) => number + value;
// Only change code above this line

// --------------------------------assignments-------------

//  Чтобы помочь нам создавать более гибкие функции, ES6 вводит параметр rest для параметров функции. С помощью параметра rest вы можете создавать функции, которые принимают переменное количество аргументов. Эти аргументы хранятся в массиве, доступ к которому можно получить позже из функции.

// Проверьте этот код:

// function howMany(...args) {
//   return "You have passed " + args.length + " arguments.";
// }
// console.log(howMany(0, 1, 2));
// console.log(howMany("string", null, [1, 2, 3], { }));
// Консоль отобразит строки You have passed 3 arguments и You have passed 4 arguments..

// Параметр rest избавляет от необходимости проверять argsмассив и позволяет применять map(), filter() и reduce()к массиву параметров.

//11) Измените функцию, sum используя оставшийся параметр, таким образом, чтобы функция sum могла принимать любое количество аргументов и возвращать их сумму.

// ------------------------------- Answer -------------------------

const sum = (...args) => {
  return args.reduce((a, b) => a + b, 0);
};

// --------------------------------assignments-------------

// ES6 представляет оператор распространения , который позволяет нам расширять массивы и другие выражения в местах, где ожидается несколько параметров или элементов.

// Код ES5 ниже использует apply()для вычисления максимального значения в массиве:

// var arr = [6, 89, 3, 45];
// var maximus = Math.max.apply(null, arr);
// maximusбудет иметь значение 89.

// Мы должны были использовать Math.max.apply(null, arr)потому что Math.max(arr)возвращает NaN. Math.max()ожидает аргументы, разделенные запятыми, но не массив. Оператор распространения делает этот синтаксис намного более удобным для чтения и обслуживания.

// const arr = [6, 89, 3, 45];
// const maximus = Math.max(...arr);
// maximusбудет иметь значение 89.

// ...arrвозвращает распакованный массив. Другими словами, он расширяет массив. Однако оператор расширения работает только на месте, например, в аргументе функции или в литерале массива. Следующий код не будет работать:

// const spreaded = ...arr;
//12) Скопируйте все содержимое arr1в другой массив, arr2используя оператор распространения.

// ------------------------------- Answer -------------------------

const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];
let arr2;

arr2 = [...arr1]; // Change this line

console.log(arr2);

// --------------------------------assignments---------------------

// Деструктурирующее присваивание — это специальный синтаксис, введенный в ES6, для аккуратного присваивания значений, взятых непосредственно из объекта.

// Рассмотрим следующий код ES5:

// const user = { name: 'John Doe', age: 34 };

// const name = user.name;
// const age = user.age;
// nameбудет иметь значение строки John Doeи ageчисло 34.

// Вот эквивалентный оператор присваивания, использующий синтаксис деструктурирования ES6:

// const { name, age } = user;
// Опять же, nameбудет иметь значение строки John Doeи ageчисло 34.

// Здесь будут созданы переменные nameи и им будут присвоены значения их соответствующих значений из объекта. Вы можете видеть, насколько это чище.ageuser

// Вы можете извлечь столько значений из объекта, сколько хотите.

// 13) Замените два назначения эквивалентным назначением деструктурирования. Он по-прежнему должен назначать переменные todayи tomorrowзначения объекта todayи tomorrowиз него HIGH_TEMPERATURES.

// ------------------------------- Answer -------------------------

const HIGH_TEMPERATURES = {
  yesterday: 75,
  today: 77,
  tomorrow: 80,
};

// Only change code below this line

const { today, tomorrow } = HIGH_TEMPERATURES;

// Only change code above this line
